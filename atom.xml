<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://quenkar.github.io</id>
    <title>quenkar</title>
    <updated>2020-09-27T12:19:46.731Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://quenkar.github.io"/>
    <link rel="self" href="https://quenkar.github.io/atom.xml"/>
    <subtitle>我已经决定吃喜欢的东西，过短命的人生了</subtitle>
    <logo>https://quenkar.github.io/images/avatar.png</logo>
    <icon>https://quenkar.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, quenkar</rights>
    <entry>
        <title type="html"><![CDATA[IDEA推荐插件及相关配置]]></title>
        <id>https://quenkar.github.io/post/idea-tui-jian-cha-jian-ji-xiang-guan-pei-zhi/</id>
        <link href="https://quenkar.github.io/post/idea-tui-jian-cha-jian-ji-xiang-guan-pei-zhi/">
        </link>
        <updated>2020-09-27T12:10:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="material-theme-ui">Material Theme UI</h3>
<h3 id="atom-material-icons">Atom Material Icons</h3>
<p>皮肤插件，还是十分好看的，直接上图</p>
<figure data-type="image" tabindex="1"><img src="https://quenkar.github.io/post-images/1601208831704.png" alt="" loading="lazy"></figure>
<h3 id="codeglance">CodeGlance</h3>
<p>类似与vscode的侧边栏，代码缩略滚动，还可以直接显示鼠标停留的那段代码<br>
<img src="https://quenkar.github.io/post-images/1601208817674.png" alt="" loading="lazy"></p>
<h3 id="codota">Codota</h3>
<p>可以直接在IDEA中查询某个类以及相关方法的使用，给出的例子也都不错。</p>
<p><strong>Ctrl+Shift+y</strong>显示查询框<br>
<img src="https://quenkar.github.io/post-images/1601209107527.png" alt="" loading="lazy"></p>
<p>以String类举例：</p>
<figure data-type="image" tabindex="2"><img src="https://quenkar.github.io/post-images/1601209111494.png" alt="" loading="lazy"></figure>
<h3 id="ide-features-trainer">IDE Features Trainer</h3>
<p>推荐学习IDEA使用教程，主要是快捷键方面的使用。假如之前没用过还是值得学一下，可以提高编程效率哦。</p>
<p>（英文教程，需要一些英语知识哦）<br>
<img src="https://quenkar.github.io/post-images/1601209098876.png" alt="" loading="lazy"></p>
<h3 id="key-promoter-x">Key Promoter X</h3>
<p>IDEA快捷键记录，会提示相关功能的快捷键提示，还会显示个人常用的快捷键，有时候忘记了一些快捷键的使用，可以直接去翻翻。</p>
<figure data-type="image" tabindex="3"><img src="https://quenkar.github.io/post-images/1601209128617.png" alt="" loading="lazy"></figure>
<h3 id="rainbow-brackets">Rainbow Brackets</h3>
<p>嵌套括号彩色显示，可以更好的区分代码块<br>
<img src="https://quenkar.github.io/post-images/1601209134103.png" alt="" loading="lazy"></p>
<p>以上就是我使用的一些插件，over</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[208/实现前缀树（字典树）]]></title>
        <id>https://quenkar.github.io/post/208shi-xian-qian-zhui-shu-zi-dian-shu/</id>
        <link href="https://quenkar.github.io/post/208shi-xian-qian-zhui-shu-zi-dian-shu/">
        </link>
        <updated>2020-09-25T06:13:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。<br>
示例:</p>
<pre><code class="language-c++">Trie trie = new Trie();
trie.insert(&quot;apple&quot;); 
trie.search(&quot;apple&quot;); // 返回 true 
trie.search(&quot;app&quot;); // 返回 false
trie.startsWith(&quot;app&quot;); // 返回 true 
trie.insert(&quot;app&quot;);
trie.search(&quot;app&quot;);// 返回 true 
</code></pre>
<p>说明:你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。</p>
<pre><code class="language-c++">class Trie
{
private:
	bool is_string = false;
	Trie* next[26] = { nullptr };
public:
	Trie()
    {
    }

	void insert(const string&amp; word)//插入单词
	{
		Trie* root = this;
		for (const auto&amp; w : word) {
			if (root-&gt;next[w - 'a'] == nullptr)root-&gt;next[w - 'a'] = new Trie();
			root = root-&gt;next[w - 'a'];
		}
		root-&gt;is_string = true;
	}

	bool search(const string&amp; word)//查找单词
	{
		Trie* root = this;
		for (const auto&amp; w : word) {
			if (root-&gt;next[w - 'a'] == nullptr)return false;
			root = root-&gt;next[w - 'a'];
		}
		return root-&gt;is_string;
	}

	bool startsWith(const string&amp; prefix)//查找前缀
	{
		Trie* root = this;
		for (const auto&amp; p : prefix) {
			if (root-&gt;next[p - 'a'] == nullptr)return false;
			root = root-&gt;next[p - 'a'];
		}
		return true;
	}
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[547. 朋友圈/并查集]]></title>
        <id>https://quenkar.github.io/post/547-peng-you-quan-bing-cha-ji/</id>
        <link href="https://quenkar.github.io/post/547-peng-you-quan-bing-cha-ji/">
        </link>
        <updated>2020-09-24T09:18:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
<p>示例 1：<br>
输入：<br>
[[1,1,0],<br>
[1,1,0],<br>
[0,0,1]]<br>
输出：2<br>
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。<br>
第2个学生自己在一个朋友圈。所以返回 2 。</p>
<p>示例 2：<br>
输入：<br>
[[1,1,0],<br>
[1,1,1],<br>
[0,1,1]]<br>
输出：1<br>
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。<br>
 <br>
提示：<br>
1 &lt;= N &lt;= 200<br>
M[i][i] == 1<br>
M[i][j] == M[j][i]</p>
<h1 id="题解">题解</h1>
<pre><code class="language-c++">class Solution {
public:
    int find(vector&lt;int&gt; &amp;Vec,int n){
        if(Vec[n]==-1)
            return n;
        return find(Vec,Vec[n]);
    }
    //将m节点连接到n上
    void Union(vector&lt;int&gt; &amp;Vec,int m,int n){
        int parent_m=find(Vec,m);
        int parent_n=find(Vec,n);
        if(parent_m!=parent_n)
            Vec[parent_m]=parent_n;
    }

    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int n=M.size();
        int res=0;
        vector&lt;int&gt; union_set(n,-1);
        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;i;j++)
            {
                if(M[i][j]==1)
                Union(union_set,j,i);
            }
        }
        for(int i=0;i&lt;n;i++)
            if(union_set[i]==-1)
                res++;
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL 常见insert()详解]]></title>
        <id>https://quenkar.github.io/post/stl-chang-jian-insertxiang-jie/</id>
        <link href="https://quenkar.github.io/post/stl-chang-jian-insertxiang-jie/">
        </link>
        <updated>2020-09-24T09:14:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="map与set的insert操作">map与set的insert操作</h1>
<p><code>std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );</code></p>
<pre><code>template&lt; class P &gt;
std::pair&lt;iterator,bool&gt; insert( P&amp;&amp; value );
</code></pre>
<p>(C++11 起)<br>
主要注意一个返回值是由被插入元素（或阻止插入元素）的迭代器和一个bool值（插入成功为true失败则为false）。</p>
<h1 id="list的insert操作">list的insert操作</h1>
<p>在pos前插入1个value元素：<br>
<code>iterator insert( iterator pos, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, const T&amp; value );</code><br>
(C++11 起)<br>
在pos前插入count个value元素：<br>
<code>void insert( iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 起)</p>
<h1 id="vector的insert操作">vector的insert操作</h1>
<p>同list差不多<br>
<code>iterator insert( iterator pos, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, const T&amp; value );</code><br>
(C++11 起)<br>
<code>void insert( iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 起)</p>
<h1 id="deque的insert操作">deque的insert操作</h1>
<p><code>iterator insert( iterator pos, const T&amp; value );</code><br>
(C++11 前)</p>
<p><code>iterator insert( const_iterator pos, const T&amp; value );</code><br>
(C++11 起)</p>
<p><code>void insert( iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 前)</p>
<p><code>iterator insert( const_iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 起)</p>
<h1 id="string的insert操作">string的insert操作</h1>
<ol>
<li>在位置 index 插入 count 个字符 ch 的副本。<br>
<code>basic_string&amp; insert( size_type index, size_type count, CharT ch );</code></li>
<li>在位置 index 插入 s 所指向的空终止字符串。字符串的长度由首个空字符，用 Traits::length(s) 确定。<br>
<code>basic_string&amp; insert( size_type index, const CharT* s );</code></li>
<li>在位置 index 插入范围 [s, s+count) 中的字符。范围能含有空字符。<br>
<code>basic_string&amp; insert( size_type index, const CharT* s, size_type count );</code></li>
<li>在位置 index 插入 string str 。<br>
<code>basic_string&amp; insert( size_type index, const basic_string&amp; str );</code></li>
<li>在 pos 所指向的字符前插入字符 ch 。<br>
<code>iterator insert( iterator pos, CharT ch );</code></li>
<li>在 pos 所指向的元素（若存在）前插入 count 个字符 ch 的副本。<br>
<code>insert( iterator pos, size_type count, CharT ch );</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZSH+oh-my-zsh配置]]></title>
        <id>https://quenkar.github.io/post/zshoh-my-zsh-pei-zhi/</id>
        <link href="https://quenkar.github.io/post/zshoh-my-zsh-pei-zhi/">
        </link>
        <updated>2020-09-24T09:11:50.000Z</updated>
        <content type="html"><![CDATA[<p>环境：deepin（Ubuntu也通用）<br>
1.安装zsh<br>
<code>sudo apt-get install zsh</code><br>
2.切换bash为zsh<br>
<code>chsh -s /bin/zsh</code><br>
如果要切回bash就：<br>
<code>chsh -s /bin/bash</code><br>
3.安装oh-my-zsh<br>
从GitHub上面拉取下来，放在~/.oh-my-zsh目录下<br>
<code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code><br>
备份已有的zshrc, 替换zshrc<br>
<code>cp ~/.zshrc ~/.zshrc.orig</code><br>
<code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code><br>
配置主题：<br>
<code>vim ~/.zshrc</code><br>
推荐ys这个主题：<br>
<code>ZSH_THEME=&quot;ys&quot;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[152/乘积最大子序列]]></title>
        <id>https://quenkar.github.io/post/152cheng-ji-zui-da-zi-xu-lie/</id>
        <link href="https://quenkar.github.io/post/152cheng-ji-zui-da-zi-xu-lie/">
        </link>
        <updated>2020-09-21T09:30:40.000Z</updated>
        <content type="html"><![CDATA[<p><strong>题目：</strong><br>
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。<br>
示例 1:<br>
输入: [2,3,-2,4]<br>
输出: 6<br>
解释: 子数组 [2,3] 有最大乘积 6。<br>
示例 2:<br>
输入: [-2,0,-1]<br>
输出: 0<br>
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>从别人那里扒来的神奇解法，主要是要注意负数的情况，当遇到一个负数的时候不能确定后面还有没有负数可以使结果变得更大，需要维护一个最小值来记录。<br>
这里使用<strong>swap进行交换，因为遇到负数，之前最大的变成最小的，最小的反而变成最大数</strong>。（这也太难想了😪）</p>
<pre><code class="language-c++">class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int imax=1,imin=1,ans=INT_MIN;

        for(int i:nums)
        {
            if(i&lt;0)
                swap(imin,imax);

            imax=max(imax*i,i);
            imin=min(imin*i,i);
        
            ans=max(ans,imax);
        }
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[128/最长连续序列]]></title>
        <id>https://quenkar.github.io/post/128zui-chang-lian-xu-xu-lie/</id>
        <link href="https://quenkar.github.io/post/128zui-chang-lian-xu-xu-lie/">
        </link>
        <updated>2020-09-20T14:36:54.000Z</updated>
        <content type="html"><![CDATA[<p><strong>题目：</strong><br>
给定一个未排序的整数数组，找出最长连续序列的长度。<br>
要求算法的时间复杂度为 O(n)。<br>
示例:<br>
输入: [100, 4, 200, 1, 3, 2]<br>
输出: 4<br>
解释: 最长连续序列是 [1, 2, 3, 4]。<br>
它的长度为 4。<br>
<strong>方法一：哈希表</strong></p>
<pre><code class="language-c++">class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; st;

        for(int i:nums)st.insert(i);
        int ans=0;
        for(int i:st)
        {
            if(i!=INT_MIN&amp;&amp;st.count(i-1))
                continue;
            
            int cnt=1;
            while(i!=INT_MIN&amp;&amp;st.count(i+1))
            {
                cnt++;i++;
            }
            ans=max(ans,cnt);
        }
        return ans;
    }

};
</code></pre>
<p><strong>方法二：排序+遍历</strong></p>
<pre><code class="language-c++">class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        int m=nums.size();
        if(m==0)return 0;

        sort(nums.begin(),nums.end());

        vector&lt;int&gt; dp(nums.size(),1);
        int mlong=1;
        for(int i=1;i&lt;nums.size();i++)
        {
            if(nums[i]==nums[i-1]+1)
            {
                dp[i]+=dp[i-1];
                mlong=max(dp[i],mlong);
            }
            else if(nums[i]==nums[i-1])
                dp[i]=dp[i-1];
        }
        return mlong;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>