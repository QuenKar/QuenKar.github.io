<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://quenkar.github.io</id>
    <title>quenkar</title>
    <updated>2020-10-11T12:19:47.566Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://quenkar.github.io"/>
    <link rel="self" href="https://quenkar.github.io/atom.xml"/>
    <subtitle>我已经决定吃喜欢的东西，过短命的人生了</subtitle>
    <logo>https://quenkar.github.io/images/avatar.png</logo>
    <icon>https://quenkar.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, quenkar</rights>
    <entry>
        <title type="html"><![CDATA[Maven配置]]></title>
        <id>https://quenkar.github.io/post/maven-pei-zhi/</id>
        <link href="https://quenkar.github.io/post/maven-pei-zhi/">
        </link>
        <updated>2020-10-11T12:14:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装maven">安装Maven</h2>
<h3 id="下载">下载</h3>
<p>http://maven.apache.org/</p>
<h3 id="配置环境变量">配置环境变量</h3>
<p>以我的计算机为例：</p>
<p><code>MAVEN_HOME D:\apache-maven-3.6.3 path</code> <code>%MAVEN_HOME%\bin</code></p>
<h3 id="查看-maven-版本信息验证安装是否正确">查看 Maven 版本信息验证安装是否正确</h3>
<p><code>mvn -v</code></p>
<figure data-type="image" tabindex="1"><img src="https://quenkar.github.io/post-images/1602418609000.png" alt="" loading="lazy"></figure>
<h2 id="配置本地仓库和阿里云镜像">配置本地仓库和阿里云镜像</h2>
<h3 id="配置本地仓库">配置本地仓库</h3>
<p>Maven 的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插 件来完成。Maven 核心程序会到本地仓库中查找插件。如果本地仓库中 没有就会从远程中央仓库下载。此时如果不能上网则无法执行 Maven 的 具体功能。为了解决这个问题，我们可以将 Maven 的本地仓库指向一个 在联网情况下下载好的目录。</p>
<p>Maven 默认的本地仓库：</p>
<p>~.m2\repository 目录</p>
<h3 id="找到-maven-的核心配置文件-settingsxml">找到 Maven 的核心配置文件 settings.xml</h3>
<p>文件： 解压目录 D:\apache-maven-3.6.3\conf\settings.xml</p>
<p>设置方式 本地仓库的路径 E:\LocalRepository</p>
<figure data-type="image" tabindex="2"><img src="https://quenkar.github.io/post-images/1602418620472.png" alt="" loading="lazy"></figure>
<h2 id="配置阿里云镜像">配置阿里云镜像</h2>
<pre><code class="language-xml">&lt;mirrors&gt;
 &lt;mirror&gt;

   &lt;id&gt;alimaven&lt;/id&gt;

   &lt;name&gt;aliyun maven&lt;/name&gt;

   &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;

   &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    

  &lt;/mirror&gt;
&lt;/mirrors&gt;
</code></pre>
<h2 id="在-idea-中使用-maven">在 Idea 中使用 Maven</h2>
<p><code>Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven</code></p>
<figure data-type="image" tabindex="3"><img src="https://quenkar.github.io/post-images/1602418626351.png" alt="" loading="lazy"></figure>
<p>将前面配置过的setting.xml覆盖原来的，再自己选择一个仓库，或者使用默认C盘下的仓库</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL-常见函数]]></title>
        <id>https://quenkar.github.io/post/mysql-chang-jian-han-shu/</id>
        <link href="https://quenkar.github.io/post/mysql-chang-jian-han-shu/">
        </link>
        <updated>2020-10-08T10:50:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="字符函数">字符函数</h2>
<h3 id="length"># length</h3>
<p>SELECT LENGTH('张三');	#utf8汉字占三个字节</p>
<p>-&gt;<code>6</code></p>
<h3 id="concat"># concat</h3>
<pre><code class="language-sql"> SELECT 
  CONCAT(last_name, '_', first_name) 
 FROM
  employees ;
 # lower,upper
 SELECT 
  CONCAT(
   LOWER(last_name),
   '_',
   UPPER(first_name)
  ) 
 FROM
  employees ;
</code></pre>
<h3 id="substrsubstring"># substr,substring</h3>
<p># <strong>！！！important</strong>：<strong>sql索引下标从1开始</strong></p>
<pre><code class="language-sql"> SELECT SUBSTR('李莫愁爱上了陆湛远',7) output;
 SELECT SUBSTR('李莫愁爱上了陆湛远',1,3) output;

 SELECT 
  CONCAT(
   UPPER(SUBSTR(last_name, 1, 1)),
   '_',
   LOWER(SUBSTR(last_name, 2))
  ) AS output 
 FROM
  employees 
 ORDER BY output ; 
</code></pre>
<h3 id="instr"># instr</h3>
<p>返回字串第一次在主串的下不标，<strong>找不到返回0</strong></p>
<pre><code class="language-sql"> SELECT 
  INSTR(
   '杨不悔爱上了殷刘侠',
   '殷刘侠'
  ) AS output ;
</code></pre>
<h3 id="trim"># trim</h3>
<p><code>SELECT LENGTH(TRIM(' abc ')) AS output;</code>-&gt;<code>abc</code></p>
<p><code>SELECT TRIM('a' FROM 'aaaaaaa张aaa翠aaa三aaaaaaa') output;</code>-&gt;<code>张aaa翠aaa三</code></p>
<h3 id="lpad"># lpad</h3>
<p>用指定的字符左填充<br>
<code>SELECT LPAD('fdsfds',10,'*') output;</code></p>
<h3 id="rpad"># rpad</h3>
<p><code>SELECT RPAD('fdsfds',10,'&amp;') output;</code></p>
<h3 id="replace"># replace</h3>
<p><code>SELECT REPLACE('张无忌爱上了周芷若','周芷若','张敏') output;</code></p>
<h2 id="数学函数">数学函数</h2>
<h3 id="round"># round</h3>
<p>四舍五入<br>
<code>SELECT ROUND(1.48);</code>-&gt;2<br>
<code>SELECT ROUND(-1.75);</code>-&gt;-2<br>
<code>SELECT ROUND(1.895,2);</code> -&gt;1.90</p>
<h3 id="rand">#  rand</h3>
<p><code>select rand()*10;</code>-&gt;<code>返回[0,10)随机值</code></p>
<h3 id="ceil"># ceil</h3>
<p>向上取整<br>
<code>SELECT CEIL(1.07);</code></p>
<h3 id="floor"># floor</h3>
<p>向下取整<br>
<code>SELECT FLOOR(-2.02);</code></p>
<h3 id="truncate"># truncate</h3>
<p>截断<br>
<code>SELECT TRUNCATE(1.654382194,2);</code></p>
<h3 id="mod"># mod</h3>
<p>取余 mod(a,b) == <strong>a-a/b*b;</strong><br>
<code>SELECT MOD(10, - 3) ;</code></p>
<h2 id="日期函数">日期函数</h2>
<h3 id="now">#now</h3>
<p><code>SELECT NOW() ;</code></p>
<h3 id="curdate">#curdate</h3>
<p><code>SELECT CURDATE() ;</code></p>
<h3 id="curtime">#curtime</h3>
<pre><code class="language-sql">SELECT 
  CURTIME() ;


 SELECT 
  YEAR(NOW()) ;

 SELECT 
  MONTH(NOW()) ;

 SELECT 
  DAY(NOW()) ;

 SELECT 
  HOUR(NOW()) ;
 SELECT 
  MINUTE(NOW()) ;
 SELECT 
  SECOND(NOW()) ;
</code></pre>
<h3 id="str_to_date"># str_to_date</h3>
<pre><code class="language-sql"> SELECT STR_TO_DATE('2010-10-3','%Y-%c-%d');

 SELECT 
  * 
 FROM
  employees 
 WHERE hiredate = '1992-4-3' ;
</code></pre>
<h3 id="date_format"># date_format</h3>
<p><code>SELECT DATE_FORMAT(NOW(),'%Y-%m-%d:%H-%i-%s');</code></p>
<h2 id="其他函数">其他函数</h2>
<p>SELECT VERSION();</p>
<p>SELECT DATABASE();</p>
<p>SELECT USER();</p>
<h3 id="if函数"># if函数</h3>
<pre><code class="language-sql"> SELECT 
  IF(10 &gt; 5, 'true', 'false') ;

 SELECT 
  last_name,
  commission_pct,
  IF(
   commission_pct IS NULL,
   '没奖金',
   '有奖'
  ) output 
 FROM
  employees ;
</code></pre>
<h3 id="case函数"># case函数</h3>
<p>语法：<br>
case: 判断的字段或者表达式<br>
when 常量1 then 要显示的值或者语句<br>
when 常量2 then 要显示的值或者语句<br>
else 要显示的值或者语句<br>
end</p>
<pre><code class="language-sql"> SELECT salary,department_id,
 CASE department_id
 WHEN 30 THEN salary*1.1
 WHEN 40 THEN salary*1.2
 WHEN 50 THEN salary*1.3
 ELSE salary
 END AS 新工资
 FROM employees;
</code></pre>
<h4 id="2-类似于多重ifelse"># 2 类似于多重if……else</h4>
<p>case<br>
when 条件1 then 要显示的值或者语句<br>
when 条件2 then 要显示的值或者语句<br>
else 要显示的值或者语句<br>
end</p>
<pre><code class="language-sql"> SELECT 
  salary,
  CASE
   WHEN salary &gt; 20000 
   THEN 'A' 
   WHEN salary &gt; 15000 
   THEN 'B' 
   WHEN salary &gt; 10000 
   THEN 'C' 
   ELSE 'D' 
  END AS 工资级别 
 FROM
  employees ;
</code></pre>
<h2 id="分组函数">分组函数</h2>
<h3 id="sum"># sum</h3>
<p>求和</p>
<h3 id="max"># max</h3>
<p>最大值</p>
<h3 id="min"># min</h3>
<p>最小值</p>
<h3 id="avg"># avg</h3>
<p>平均值</p>
<h3 id="count"># count</h3>
<p>计数</p>
<p>特点：<br>
1、以上五个分组函数都忽略null值，除了count(<em>)<br>
2、sum和avg一般用于处理数值型<br>
max、min、count可以处理任何数据类型<br>
3、都可以搭配distinct使用，用于统计去重后的结果<br>
4、count的参数可以支持：<br>
字段、</em>、常量值（一般放1），<strong>建议使用 count(*)</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL-查询 ]]></title>
        <id>https://quenkar.github.io/post/mysql-cha-xun/</id>
        <link href="https://quenkar.github.io/post/mysql-cha-xun/">
        </link>
        <updated>2020-10-04T14:04:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mysql-条件查询">MySQL-条件查询</h2>
<h4 id="importantwhere">Important：where</h4>
<p><strong>语法：</strong><br>
select<br>
查询列表<br>
from<br>
表名<br>
where<br>
条件<br>
<strong>分类：</strong><br>
1.按条件表达式<br>
条件运算符： <strong>&gt; &lt; = != &gt;= &lt;=</strong></p>
<p>2.逻辑表达式<br>
逻辑运算符：<br>
<strong>&amp;&amp; || !</strong><br>
<strong>and or not</strong><br>
3.模糊查询：<br>
- <strong>like</strong><br>
- <strong>between and</strong><br>
- <strong>in</strong><br>
- <strong>is null</strong></p>
<h4 id="按条件表达式"># 按条件表达式</h4>
<p><code>SELECT * FROM employees WHERE salary&gt;12000;</code></p>
<pre><code class="language-sql"> SELECT 
  last_name,
  department_id 
 FROM
  employees 
 WHERE department_id != 90 ;
</code></pre>
<h4 id="按逻辑表达式"># 按逻辑表达式</h4>
<pre><code class="language-sql"> SELECT 
  last_name,
  salary,
  commission_pct 
 FROM
  employees 
 WHERE salary &gt;= 10000 
  AND salary &lt;= 20000 ;

 SELECT 
  * 
 FROM
  employees 
 WHERE department_id &lt; 90 || department_id &gt; 110 || salary &gt; 15000 ;
</code></pre>
<h4 id="模糊查询"># 模糊查询</h4>
<h5 id="like">like</h5>
<p>一般和通配符使用<br>
<strong>%任意多个字符</strong><br>
<strong>_任意单个字符</strong></p>
<pre><code class="language-sql"> SELECT 
  * 
 FROM
  employees 
 WHERE last_name LIKE '%a%' ;

 SELECT 
  * 
 FROM
  employees 
 WHERE last_name LIKE '__n_l%' ;
 # 假如要搜索的字段中包含_或者%时,用转义字符 \
 SELECT * FROM employees WHERE last_name LIKE '_\_%';
 # 自定义转义字符
 SELECT * FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$';
</code></pre>
<h5 id="between-and">between and</h5>
<pre><code class="language-sql"> SELECT 
  * 
 FROM
  employees 
 WHERE employee_id BETWEEN 100 AND 120 ;
</code></pre>
<p><strong># 包含临界值的，相当于 [100,120]</strong></p>
<h5 id="in">in</h5>
<p><strong>值类型要一直或者能相互转化,不支持使用通配符</strong></p>
<pre><code class="language-sql">SELECT 
  * 
 FROM
  employees 
 WHERE job_id IN (
   'AD_PRES',
   'IT_PROG',
   'IT_PROG',
   'FI_ACCOUNT'
  );
</code></pre>
<h5 id="is-null">is null</h5>
<p><strong>用is判断null，而不能直接用 = null这种写法，=与!=不能判断null值</strong></p>
<pre><code class="language-sql"> SELECT 
  last_name,
  commission_pct 
 FROM
  employees 
 WHERE commission_pct IS NULL ;
</code></pre>
<h5 id="安全等于">安全等于&lt;=&gt;</h5>
<pre><code class="language-sql"> SELECT 
  last_name,
  commission_pct 
 FROM
  employees 
 WHERE commission_pct &lt;=&gt; NULL ;


 SELECT 
  last_name,
  salary 
 FROM
  employees 
 WHERE salary &lt;=&gt; 12000 ;
</code></pre>
<h6 id="summary"><strong>summary</strong></h6>
<p>is null: 仅仅可以判断null值<br>
&lt;=&gt;  : 既可以判断null值，也可以判断普通的值</p>
<h5 id="addition">Addition</h5>
<p><strong>Question：</strong><code>select * from employees;</code>和<code>select * from employees where commission_pct like '%%' and last_name like '%%';</code>结果是否一样？</p>
<p>**Answer：**不一样，第二个sql语句commission_pct为null的时候没法检索出来，假如没有字段为null，就是一样的。</p>
<h2 id="mysql-排序查询">MySQL-排序查询</h2>
<h4 id="order-by-语法">ORDER BY 语法</h4>
<pre><code class="language-sql"> select 查询列表
 from 表
 [where 条件]
 [order by 排序列表 [asc|desc]
  
  # asc : 升序
  # desc : 降序
</code></pre>
<p><code>order by</code> 支持<strong>单个字段，多个字段，表达式，函数</strong><br>
<strong>一般放在查询语句最后面，除了limit子句</strong></p>
<h4 id="使用样例">使用样例</h4>
<pre><code class="language-sql"> # 1
 SELECT 
  * 
 FROM
  employees 
 ORDER BY salary ;

 # 2
 SELECT 
  * 
 FROM
  employees 
 WHERE department_id &gt;= 90 
 ORDER BY hiredate ;

 # 3 按表达式排序(支持别名)
 SELECT 
  *,
  salary * 12 * (1+ IFNULL(commission_pct, 0)) AS 年薪 
 FROM
  employees 
 ORDER BY 年薪 DESC ;

 # 4 按姓名的长度排序
 SELECT 
  last_name,
  salary 
 FROM
  employees 
 ORDER BY LENGTH(last_name) ;

 # 5先按工资排序再按员工编号排序(按多个字段排序)
 SELECT *
 FROM employees
 ORDER BY salary,employee_id DESC;

 #test problems
 # 1
 SELECT 
  last_name,
  department_id,
  salary * 12 * (1+ IFNULL(commission_pct, 0)) AS 年薪 
 FROM
  employees 
 ORDER BY 年薪 DESC,# 年薪不能加''
  last_name ;

 # 2
 SELECT 
  * 
 FROM
  employees 
 WHERE salary &lt; 8000 || salary &gt; 17000 
 ORDER BY salary DESC ;

 # 3
 SELECT 
  * 
 FROM
  employees 
 WHERE email LIKE '%e%' 
 ORDER BY LENGTH(email) DESC,
  department_id ;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL-基础]]></title>
        <id>https://quenkar.github.io/post/mysql-ji-chu/</id>
        <link href="https://quenkar.github.io/post/mysql-ji-chu/">
        </link>
        <updated>2020-10-03T14:02:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础关键字">基础关键字</h2>
<p><strong>SELECT</strong> <strong>FROM</strong></p>
<h4 id="查询一个字段"># 查询一个字段</h4>
<pre><code class="language-sql"> SELECT 
  last_name 
 FROM
  employees ;
</code></pre>
<h4 id="查询多个字段"># 查询多个字段</h4>
<pre><code class="language-sql"> SELECT 
  last_name,
  salary,
  email 
 FROM
  employees ;
</code></pre>
<h4 id="查询所有字段"># 查询所有字段</h4>
<pre><code class="language-sql"> SELECT 
   * 
 FROM
  employees ;
</code></pre>
<h4 id="查询常量值"># 查询常量值</h4>
<p><code>SELECT 100;</code></p>
<p><code>SELECT 'john';</code></p>
<h4 id="查询表达式"># 查询表达式</h4>
<p><code>SELECT 100*4398;</code></p>
<h4 id="查询函数"># 查询函数</h4>
<p><code>SELECT VERSION() ;</code></p>
<h4 id="起别名"># 起别名</h4>
<p><code>SELECT 100%98 AS result;</code></p>
<p><code>SELECT last_name 姓,first_name 名 FROM employees;</code></p>
<p><code>SELECT salary AS &quot;out put&quot; FROM employees;</code></p>
<h4 id="去重"># 去重</h4>
<p><code>SELECT DISTINCT department_id FROM employees;</code></p>
<h4 id="mysql中的号">#  mysql中的+号</h4>
<p><strong>只有运算符的作用，不会像java或者c++一样可以直接拼接字符串</strong></p>
<pre><code class="language-sql"> select 100+50;
 select '123'+79;# 试图将字符串转为数字型，转换成功继续做加法
 select 'john'+40;# 假如转换失败，则字符型转换成0
 select null+10;# 只要有一方为null，结果就是null
</code></pre>
<p><code>SELECT last_name + first_name AS 姓名 FROM employees ;</code></p>
<p><strong>只会显示0</strong></p>
<h4 id="显示表的字段"># 显示表的字段</h4>
<p><code>DESC departments;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx安装]]></title>
        <id>https://quenkar.github.io/post/nginx-pei-zhi/</id>
        <link href="https://quenkar.github.io/post/nginx-pei-zhi/">
        </link>
        <updated>2020-10-01T13:48:42.000Z</updated>
        <content type="html"><![CDATA[<p><strong>环境：Ubuntu 18.04</strong></p>
<p><strong>权限：root</strong></p>
<h3 id="1安装pcre-837targz">1.安装pcre-8.37.tar.gz</h3>
<p><a href="https://ftp.pcre.org/pub/pcre/">https://ftp.pcre.org/pub/pcre/</a></p>
<p>解压 <code>tar -xvf pcre-8.37.tar.gz</code></p>
<p>进入pcre-8.37执行</p>
<p><code>./configure</code></p>
<p>然后再执行</p>
<p><code>make &amp;&amp; make install</code></p>
<p><strong>至少要在sudo权限下执行，否则就会Permission denied</strong><br>
<img src="https://quenkar.github.io/post-images/1601560193664.png" alt="" loading="lazy"></p>
<p>执行<code>pcre-config --version</code>查看版本</p>
<pre><code class="language-bash">$ pcre-config --version
8.39
</code></pre>
<h3 id="2安装nginx">2.安装Nginx</h3>
<p>前置条件安装</p>
<pre><code class="language-bash">sudo apt-get install zlib1g

sudo apt-get install zlib1g.dev

sudo apt-get install openssl

sudo apt-get install libssl-dev
</code></pre>
<p>官网下载nginx</p>
<p>http://nginx.org/en/download.html</p>
<p>以nginx-1.12.2版本演示<a href="http://nginx.org/download/nginx-1.12.2.tar.gz"> nginx-1.12.2</a></p>
<p>解压<code>tar -xvf nginx-1.12.2.tar.gz</code></p>
<p>进入解压后的目录，执行<code>./configure</code></p>
<p>权限要为<strong>root</strong>，用sudo执行照样权限不够</p>
<figure data-type="image" tabindex="1"><img src="https://quenkar.github.io/post-images/1601560218025.png" alt="" loading="lazy"></figure>
<p><strong>root权限</strong>下再执行<code>make &amp;&amp; make install</code></p>
<p>进入 <code>/usr/local/nginx/sbin</code> 执行<code>sudo ./nginx</code>启动nginx</p>
<p>到这里就算安装完成了</p>
<p>再配置一下系统防火墙，设置一下对外的端口号就可以访问了😋</p>
<figure data-type="image" tabindex="2"><img src="https://quenkar.github.io/post-images/1601560229643.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA推荐插件及相关配置]]></title>
        <id>https://quenkar.github.io/post/idea-tui-jian-cha-jian-ji-xiang-guan-pei-zhi/</id>
        <link href="https://quenkar.github.io/post/idea-tui-jian-cha-jian-ji-xiang-guan-pei-zhi/">
        </link>
        <updated>2020-09-27T12:10:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="material-theme-ui">Material Theme UI</h3>
<h3 id="atom-material-icons">Atom Material Icons</h3>
<p>皮肤插件，还是十分好看的，直接上图<br>
<img src="https://quenkar.github.io/post-images/1601208831704.png" alt="" loading="lazy"></p>
<p>不过有一点不好，注释的颜色是浅灰色的，不是很明显，我换成了深绿色（#069252）<br>
<img src="https://quenkar.github.io/post-images/1601209424372.png" alt="" loading="lazy"></p>
<h3 id="codeglance">CodeGlance</h3>
<p>类似与vscode的侧边栏，代码缩略滚动，还可以直接显示鼠标停留的那段代码<br>
<img src="https://quenkar.github.io/post-images/1601208817674.png" alt="" loading="lazy"></p>
<h3 id="codota">Codota</h3>
<p>可以直接在IDEA中查询某个类以及相关方法的使用，给出的例子也都不错。</p>
<p><strong>Ctrl+Shift+y</strong>显示查询框<br>
<img src="https://quenkar.github.io/post-images/1601209107527.png" alt="" loading="lazy"></p>
<p>以String类举例：</p>
<figure data-type="image" tabindex="1"><img src="https://quenkar.github.io/post-images/1601209111494.png" alt="" loading="lazy"></figure>
<h3 id="ide-features-trainer">IDE Features Trainer</h3>
<p>推荐学习IDEA使用教程，主要是快捷键方面的使用。假如之前没用过还是值得学一下，可以提高编程效率哦。</p>
<p>（英文教程，需要一些英语知识哦😄）<br>
<img src="https://quenkar.github.io/post-images/1601209098876.png" alt="" loading="lazy"></p>
<h3 id="key-promoter-x">Key Promoter X</h3>
<p>IDEA快捷键记录，会提示相关功能的快捷键提示，还会显示个人常用的快捷键，有时候忘记了一些快捷键的使用，可以直接去翻翻。</p>
<figure data-type="image" tabindex="2"><img src="https://quenkar.github.io/post-images/1601209128617.png" alt="" loading="lazy"></figure>
<h3 id="rainbow-brackets">Rainbow Brackets</h3>
<p>嵌套括号彩色显示，可以更好的区分代码块<br>
<img src="https://quenkar.github.io/post-images/1601209134103.png" alt="" loading="lazy"></p>
<p>以上就是我使用的一些插件，over</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[208/实现前缀树（字典树）]]></title>
        <id>https://quenkar.github.io/post/208shi-xian-qian-zhui-shu-zi-dian-shu/</id>
        <link href="https://quenkar.github.io/post/208shi-xian-qian-zhui-shu-zi-dian-shu/">
        </link>
        <updated>2020-09-25T06:13:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。<br>
示例:</p>
<pre><code class="language-c++">Trie trie = new Trie();
trie.insert(&quot;apple&quot;); 
trie.search(&quot;apple&quot;); // 返回 true 
trie.search(&quot;app&quot;); // 返回 false
trie.startsWith(&quot;app&quot;); // 返回 true 
trie.insert(&quot;app&quot;);
trie.search(&quot;app&quot;);// 返回 true 
</code></pre>
<p>说明:你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。</p>
<pre><code class="language-c++">class Trie
{
private:
	bool is_string = false;
	Trie* next[26] = { nullptr };
public:
	Trie()
    {
    }

	void insert(const string&amp; word)//插入单词
	{
		Trie* root = this;
		for (const auto&amp; w : word) {
			if (root-&gt;next[w - 'a'] == nullptr)root-&gt;next[w - 'a'] = new Trie();
			root = root-&gt;next[w - 'a'];
		}
		root-&gt;is_string = true;
	}

	bool search(const string&amp; word)//查找单词
	{
		Trie* root = this;
		for (const auto&amp; w : word) {
			if (root-&gt;next[w - 'a'] == nullptr)return false;
			root = root-&gt;next[w - 'a'];
		}
		return root-&gt;is_string;
	}

	bool startsWith(const string&amp; prefix)//查找前缀
	{
		Trie* root = this;
		for (const auto&amp; p : prefix) {
			if (root-&gt;next[p - 'a'] == nullptr)return false;
			root = root-&gt;next[p - 'a'];
		}
		return true;
	}
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[547. 朋友圈/并查集]]></title>
        <id>https://quenkar.github.io/post/547-peng-you-quan-bing-cha-ji/</id>
        <link href="https://quenkar.github.io/post/547-peng-you-quan-bing-cha-ji/">
        </link>
        <updated>2020-09-24T09:18:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
<p>示例 1：<br>
输入：<br>
[[1,1,0],<br>
[1,1,0],<br>
[0,0,1]]<br>
输出：2<br>
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。<br>
第2个学生自己在一个朋友圈。所以返回 2 。</p>
<p>示例 2：<br>
输入：<br>
[[1,1,0],<br>
[1,1,1],<br>
[0,1,1]]<br>
输出：1<br>
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。<br>
 <br>
提示：<br>
1 &lt;= N &lt;= 200<br>
M[i][i] == 1<br>
M[i][j] == M[j][i]</p>
<h1 id="题解">题解</h1>
<pre><code class="language-c++">class Solution {
public:
    int find(vector&lt;int&gt; &amp;Vec,int n){
        if(Vec[n]==-1)
            return n;
        return find(Vec,Vec[n]);
    }
    //将m节点连接到n上
    void Union(vector&lt;int&gt; &amp;Vec,int m,int n){
        int parent_m=find(Vec,m);
        int parent_n=find(Vec,n);
        if(parent_m!=parent_n)
            Vec[parent_m]=parent_n;
    }

    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int n=M.size();
        int res=0;
        vector&lt;int&gt; union_set(n,-1);
        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;i;j++)
            {
                if(M[i][j]==1)
                Union(union_set,j,i);
            }
        }
        for(int i=0;i&lt;n;i++)
            if(union_set[i]==-1)
                res++;
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL 常见insert()详解]]></title>
        <id>https://quenkar.github.io/post/stl-chang-jian-insertxiang-jie/</id>
        <link href="https://quenkar.github.io/post/stl-chang-jian-insertxiang-jie/">
        </link>
        <updated>2020-09-24T09:14:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="map与set的insert操作">map与set的insert操作</h1>
<p><code>std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );</code></p>
<pre><code>template&lt; class P &gt;
std::pair&lt;iterator,bool&gt; insert( P&amp;&amp; value );
</code></pre>
<p>(C++11 起)<br>
主要注意一个返回值是由被插入元素（或阻止插入元素）的迭代器和一个bool值（插入成功为true失败则为false）。</p>
<h1 id="list的insert操作">list的insert操作</h1>
<p>在pos前插入1个value元素：<br>
<code>iterator insert( iterator pos, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, const T&amp; value );</code><br>
(C++11 起)<br>
在pos前插入count个value元素：<br>
<code>void insert( iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 起)</p>
<h1 id="vector的insert操作">vector的insert操作</h1>
<p>同list差不多<br>
<code>iterator insert( iterator pos, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, const T&amp; value );</code><br>
(C++11 起)<br>
<code>void insert( iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 前)<br>
<code>iterator insert( const_iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 起)</p>
<h1 id="deque的insert操作">deque的insert操作</h1>
<p><code>iterator insert( iterator pos, const T&amp; value );</code><br>
(C++11 前)</p>
<p><code>iterator insert( const_iterator pos, const T&amp; value );</code><br>
(C++11 起)</p>
<p><code>void insert( iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 前)</p>
<p><code>iterator insert( const_iterator pos, size_type count, const T&amp; value );</code><br>
(C++11 起)</p>
<h1 id="string的insert操作">string的insert操作</h1>
<ol>
<li>在位置 index 插入 count 个字符 ch 的副本。<br>
<code>basic_string&amp; insert( size_type index, size_type count, CharT ch );</code></li>
<li>在位置 index 插入 s 所指向的空终止字符串。字符串的长度由首个空字符，用 Traits::length(s) 确定。<br>
<code>basic_string&amp; insert( size_type index, const CharT* s );</code></li>
<li>在位置 index 插入范围 [s, s+count) 中的字符。范围能含有空字符。<br>
<code>basic_string&amp; insert( size_type index, const CharT* s, size_type count );</code></li>
<li>在位置 index 插入 string str 。<br>
<code>basic_string&amp; insert( size_type index, const basic_string&amp; str );</code></li>
<li>在 pos 所指向的字符前插入字符 ch 。<br>
<code>iterator insert( iterator pos, CharT ch );</code></li>
<li>在 pos 所指向的元素（若存在）前插入 count 个字符 ch 的副本。<br>
<code>insert( iterator pos, size_type count, CharT ch );</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZSH+oh-my-zsh配置]]></title>
        <id>https://quenkar.github.io/post/zshoh-my-zsh-pei-zhi/</id>
        <link href="https://quenkar.github.io/post/zshoh-my-zsh-pei-zhi/">
        </link>
        <updated>2020-09-24T09:11:50.000Z</updated>
        <content type="html"><![CDATA[<p>环境：deepin（Ubuntu也通用）<br>
1.安装zsh<br>
<code>sudo apt-get install zsh</code><br>
2.切换bash为zsh<br>
<code>chsh -s /bin/zsh</code><br>
如果要切回bash就：<br>
<code>chsh -s /bin/bash</code><br>
3.安装oh-my-zsh<br>
从GitHub上面拉取下来，放在~/.oh-my-zsh目录下<br>
<code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code><br>
备份已有的zshrc, 替换zshrc<br>
<code>cp ~/.zshrc ~/.zshrc.orig</code><br>
<code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code><br>
配置主题：<br>
<code>vim ~/.zshrc</code><br>
推荐ys这个主题：<br>
<code>ZSH_THEME=&quot;ys&quot;</code></p>
]]></content>
    </entry>
</feed>