<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://quenkar.github.io</id>
    <title>quenkar</title>
    <updated>2020-09-20T14:44:46.525Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://quenkar.github.io"/>
    <link rel="self" href="https://quenkar.github.io/atom.xml"/>
    <subtitle>我已经决定吃喜欢的东西，过短命的人生了</subtitle>
    <logo>https://quenkar.github.io/images/avatar.png</logo>
    <icon>https://quenkar.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, quenkar</rights>
    <entry>
        <title type="html"><![CDATA[128/最长连续序列]]></title>
        <id>https://quenkar.github.io/post/128zui-chang-lian-xu-xu-lie/</id>
        <link href="https://quenkar.github.io/post/128zui-chang-lian-xu-xu-lie/">
        </link>
        <updated>2020-09-20T14:36:54.000Z</updated>
        <content type="html"><![CDATA[<p><strong>题目：</strong><br>
给定一个未排序的整数数组，找出最长连续序列的长度。<br>
要求算法的时间复杂度为 O(n)。<br>
示例:<br>
输入: [100, 4, 200, 1, 3, 2]<br>
输出: 4<br>
解释: 最长连续序列是 [1, 2, 3, 4]。<br>
它的长度为 4。<br>
<strong>方法一：哈希表</strong></p>
<pre><code class="language-c++">class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; st;

        for(int i:nums)st.insert(i);
        int ans=0;
        for(int i:st)
        {
            if(i!=INT_MIN&amp;&amp;st.count(i-1))
                continue;
            
            int cnt=1;
            while(i!=INT_MIN&amp;&amp;st.count(i+1))
            {
                cnt++;i++;
            }
            ans=max(ans,cnt);
        }
        return ans;
    }

};
</code></pre>
<p><strong>方法二：排序+遍历</strong></p>
<pre><code class="language-c++">class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        int m=nums.size();
        if(m==0)return 0;

        sort(nums.begin(),nums.end());

        vector&lt;int&gt; dp(nums.size(),1);
        int mlong=1;
        for(int i=1;i&lt;nums.size();i++)
        {
            if(nums[i]==nums[i-1]+1)
            {
                dp[i]+=dp[i-1];
                mlong=max(dp[i],mlong);
            }
            else if(nums[i]==nums[i-1])
                dp[i]=dp[i-1];
        }
        return mlong;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>