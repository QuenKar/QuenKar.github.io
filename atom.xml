<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://quenkar.github.io</id>
    <title>quenkar</title>
    <updated>2020-09-24T00:06:59.101Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://quenkar.github.io"/>
    <link rel="self" href="https://quenkar.github.io/atom.xml"/>
    <subtitle>我已经决定吃喜欢的东西，过短命的人生了</subtitle>
    <logo>https://quenkar.github.io/images/avatar.png</logo>
    <icon>https://quenkar.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, quenkar</rights>
    <entry>
        <title type="html"><![CDATA[152/乘积最大子序列]]></title>
        <id>https://quenkar.github.io/post/152cheng-ji-zui-da-zi-xu-lie/</id>
        <link href="https://quenkar.github.io/post/152cheng-ji-zui-da-zi-xu-lie/">
        </link>
        <updated>2020-09-21T09:30:40.000Z</updated>
        <content type="html"><![CDATA[<p><strong>题目：</strong><br>
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。<br>
示例 1:<br>
输入: [2,3,-2,4]<br>
输出: 6<br>
解释: 子数组 [2,3] 有最大乘积 6。<br>
示例 2:<br>
输入: [-2,0,-1]<br>
输出: 0<br>
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>从别人那里扒来的神奇解法，主要是要注意负数的情况，当遇到一个负数的时候不能确定后面还有没有负数可以使结果变得更大，需要维护一个最小值来记录。<br>
这里使用<strong>swap进行交换，因为遇到负数，之前最大的变成最小的，最小的反而变成最大数</strong>。（这也太难想了😪）</p>
<pre><code class="language-c++">class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int imax=1,imin=1,ans=INT_MIN;

        for(int i:nums)
        {
            if(i&lt;0)
                swap(imin,imax);

            imax=max(imax*i,i);
            imin=min(imin*i,i);
        
            ans=max(ans,imax);
        }
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[128/最长连续序列]]></title>
        <id>https://quenkar.github.io/post/128zui-chang-lian-xu-xu-lie/</id>
        <link href="https://quenkar.github.io/post/128zui-chang-lian-xu-xu-lie/">
        </link>
        <updated>2020-09-20T14:36:54.000Z</updated>
        <content type="html"><![CDATA[<p><strong>题目：</strong><br>
给定一个未排序的整数数组，找出最长连续序列的长度。<br>
要求算法的时间复杂度为 O(n)。<br>
示例:<br>
输入: [100, 4, 200, 1, 3, 2]<br>
输出: 4<br>
解释: 最长连续序列是 [1, 2, 3, 4]。<br>
它的长度为 4。<br>
<strong>方法一：哈希表</strong></p>
<pre><code class="language-c++">class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; st;

        for(int i:nums)st.insert(i);
        int ans=0;
        for(int i:st)
        {
            if(i!=INT_MIN&amp;&amp;st.count(i-1))
                continue;
            
            int cnt=1;
            while(i!=INT_MIN&amp;&amp;st.count(i+1))
            {
                cnt++;i++;
            }
            ans=max(ans,cnt);
        }
        return ans;
    }

};
</code></pre>
<p><strong>方法二：排序+遍历</strong></p>
<pre><code class="language-c++">class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        int m=nums.size();
        if(m==0)return 0;

        sort(nums.begin(),nums.end());

        vector&lt;int&gt; dp(nums.size(),1);
        int mlong=1;
        for(int i=1;i&lt;nums.size();i++)
        {
            if(nums[i]==nums[i-1]+1)
            {
                dp[i]+=dp[i-1];
                mlong=max(dp[i],mlong);
            }
            else if(nums[i]==nums[i-1])
                dp[i]=dp[i-1];
        }
        return mlong;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>